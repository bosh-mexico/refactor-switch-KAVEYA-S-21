Using a switch statement in the checkout function may work for now, but as more payment modes are introduced, it will quickly become messy and difficult to maintain. This design breaks the Open/Closed Principle because the function needs to be modified every time a new mode is added. All of the payment processing logic is embedded directly inside checkout, which reduces testability and makes the code harder to extend; a cleaner approach would be to separate each payment mode’s logic into its own function or even its own module. The current structure also creates a risk of duplication, since each case performs nearly the same steps and, as the logic grows, this repetition will only increase. Another issue is the lack of input validation—the code assumes all amounts are valid, but in practice negative or zero values should be handled explicitly. The output strings are hardcoded in English, leaving no room for localization or easy customization in the future. There’s also no separation between the interface and its implementation, meaning the checkout function is tightly coupled to specific payment providers, which makes swapping or refactoring more complicated. Finally, because the function just prints results instead of returning a status or error code, it becomes difficult to integrate with other parts of a larger system or manage errors programmatically.
